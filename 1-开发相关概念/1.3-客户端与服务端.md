# 客户端与服务端

Minecraft的运行分为客户端与服务端。客户端负责**界面渲染等**，以及**将玩家在客户端的操作反馈到服务端**；而服务端负责**数据处理，游戏逻辑等**。

实际上，在单人游戏，你的电脑上也同时运行着客户端与服务端，他们位于**不同的线程**，执行着不同的工作。玩家在客户端上的操作会通过**网络发包**发送给服务端进行处理，服务端则会将处理的数据发回客户端，而客户端将对其作出反应，渲染相应的效果。

**当然，客户端也不是只负责画面渲染**。例如在多人游戏，在网络不好的时候，可能会出现走路“回弹”的现象（玩家走几步，之后又突然回到原来位置，像被弹回去一样——**中国版特色**），这是因为客户端与服务端**各有一个玩家的实例（ClientPlayer与ServerPlayer）**，玩家在客户端对ClientPlayer的操作会发包到服务端，**顺便客户端也处理**，然后再接收服务端的数据与服务端同步。网络不好引发丢包，玩家在客户端的走动操作没有发送到服务端，而服务端的玩家位置却能发送回客户端，客户端便会根据服务端的数据进行调整，因此，玩家就被“弹”回了原位置。

为什么会这样呢？因为如果玩家的实例仅存在于服务端，那每次的操作都要等待服务端发回数据再作出反应，那玩家即使是在单人游戏，走动也会变得一卡一卡的。相应的，还有玩家**左键攻击、放置方块**也会**先由客户端处理，再发包与服务端同步**（网易的吞方块）。

为什么要区分客户端与服务端呢？**这样Modder们才不用为服务器重新开发一个Mod**

## 在代码层面上如何区分？

终于讲到代码了！在`World`里有个`isRemote`字段，当处于客户端时，这个字段为`false`，当处于服务端时，这个字段为`false`。`World`里的`isRemote()`方法也是一样的道理。

### 一些需要注意的地方

在单人游戏中，客户端与服务端是同时存在的，因此不用太过注意。

**但在多人游戏中，客户端与服务端是分开的**，服务端在远程服务器上，而客户端在玩家那儿。因此，如果你想要让你的Mod能够同时在双端运行，就需要注意一下几点：

* **服务端没有渲染相关的类**，因此请不要在服务端调用任何渲染相关的类。
* 给只能在客户端运行的类与方法**加上`@OnlyIn(Dist.CLIENT)`注解**是一个好习惯。
* 与逻辑相关的代码前面要用`if (!world.isRemote)`套起来，确保只在服务端运行。与渲染相关的代码段也一样，确保只在客户端运行。